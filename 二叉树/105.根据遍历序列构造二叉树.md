### [105.根据前、中序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

#### 思路
1. 找到根节点
   1. 前序遍历的第一个元素即为根节点
   2. 根据前序遍历的根节点值，在中序遍历中找到该值的位置
2. 划分左、右子树
   1. 在中序遍历中明确了根节点后
   2. 根节点的左边为左子树
   3. 根节点的右边为右子树

```javascript
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if (!preorder.length || !inorder.length) {
        return null
    }

    let root = new TreeNode(preorder[0])

    let index = inorder.indexOf(preorder.shift())

    root.left = buildTree(preorder,inorder.slice(0,index))
    
    root.right = buildTree(preorder,inorder.slice(index+1))

    return root
};
```

### [106.根据中、后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

#### 思路
1. 找到根节点
   1. 后序遍历中，末尾元素即为根节点
   2. 根据根节点值，在中序中找到位置 index
2. 划分左右子树
   1. 后序遍历中，0-index为左子树，index及后续为右子树
   2. 中序遍历中，0-index为左子树，index+1开始为右子树

```javascript
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    if (!inorder.length || !postorder.length) {
        return null
    }
    let root  = new TreeNode(postorder.pop())
    let index = inorder.indexOf(root.val)

    root.left = buildTree(inorder.slice(0,index),postorder.slice(0,index))
    root.right = buildTree(inorder.slice(index+1),postorder.slice(index))

    return root
};

```

