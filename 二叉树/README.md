## 二叉树技巧
### 一、二叉树形式
在js中二叉树会以链表的形式表示，通常会用递归的方式进行二叉树递归。


### 二、 二叉树遍历

#### 2.1 遍历题目
二叉树通常会有前、中、后序的遍历方式，基础的二叉树遍历题如下：
[二叉树基础遍历](二叉树/../二叉树基础遍历.md)

#### 2.2 二叉树遍历模板:
```javascript
const traverse = root => {
  if (root == null) {
    return;
  }
  // ...前序位置
  traverse(root.left);
  // ...中序位置
  traverse(root.right);
  // ...后序位置
}
```

#### 2.3 技巧总结

##### 2.3.1节点的基础思考

前序位置为：**刚要进入一个节点元素的时候执行**,前序位置的代码只能从函数参数中获取父节点传递来的数据

后序位置为：**即将离开一个节点元素的时候执行**,后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据

一般题目设计到与子树有关时，大概率需要在**后序位置编写代码逻辑**，并设置好一个合理的返回值

中序位置为：**左子树都遍历完，即将开始遍历右子树的时候执行**

本人写的二叉树普通遍历题目都放在了这下面

[二叉树遍历](二叉树/../二叉树遍历.md)
##### 2.3.2 回溯算法

[二叉树回溯](./二叉树回溯.md)
个人理解为DFS算法，深度优先遍历，暴力穷举

主要的两个点：
1. 用一个属性存放已经做出的选择、for循环选择列表、无法再做选择的结束条件
2. for循环中的递归，在递归前做选择，递归后撤销选择

##### 2.3.3回溯模板
这里需要注意：
如果出现二维数组时，需要提前初始化占位数组
```javascript
let board = new Array(n).fill('.').map(()=> new Array(n).fill("."))
```

使用数组存放数据时，push数据需要进行深拷贝，避免赋值后被影响

```javascript
function backtrack (path, list) {
    result = [];
    if (满足条件) {
      // 这里要使用深拷贝，防止回溯造成的影响
        result.push(path);
        return
    }
    
    for () {
        // 做选择(前序遍历)
        backtrack (path, list)
        // 撤销选择(后续遍历)
    }
}
```

#### 2.4 递归

解决二叉树问题，一般都会用递归的方式解决，换而言之：**需要用递归的题目，就可以抽象成二叉树问题**

写递归的关键是明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节

例如树相关的算法：搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点，**递归调用会让孩子节点做相同的事情**

- 「该做什么」就是想清楚写什么代码能够实现题目想要的效果
- 「什么时候做」，就是思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上
- 把题目要求细化到每一个节点需要做的事情上


