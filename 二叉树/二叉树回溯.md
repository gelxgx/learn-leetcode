### 二叉树回溯

#### 一、easy类
[104.二叉树最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/)
```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
// 整体思路为进入节点前增加计数器数字
// 达到最大深度时，与已经记录的深度数字进行对比
// 退出时逐步减少计数器数字，直到归零
var maxDepth = function(root) {
    // 用于返回最后的最大结果
    let res = 0;
    // 用于过程中记录最大深度的动态计数器
    let count = 0;
    const depth = root => {
        if (root == null) {
            // 此时说明已经达到最大深度，进行深度对比
            res = Math.max(res,count);
            return
        }
        count++
        depth(root.left);
        depth(root.right);
        count--
    }
    depth(root);
    return res
};
```

#### 二、medium类
[46.全排列](https://leetcode-cn.com/problems/permutations/)
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    // 创建两个新的变量，一个用于存放最终结果，一个用于记录路径
    let res = [];
    let count = [];
    const dfs = (nums,count) => {
      // 创建结束条件
        if (count.length == nums.length) {
            // 记录完整路径
            res.push([...count])
            return
        }
        for (let i = 0;i<nums.length;i++) {
            // 做出路径选择
            if (count.includes(nums[i])) {
                continue
            }
            // 记录当前路径
            count.push(nums[i]);
            dfs(nums,count);
            // 结束选择
            count.pop();
        }
    }
    dfs(nums,count)
    return res;
};
```