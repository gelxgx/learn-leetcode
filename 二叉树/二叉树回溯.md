### 二叉树回溯

#### 一、easy类
[104.二叉树最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/)
```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
// 整体思路为进入节点前增加计数器数字
// 达到最大深度时，与已经记录的深度数字进行对比
// 退出时逐步减少计数器数字，直到归零
var maxDepth = function(root) {
    // 用于返回最后的最大结果
    let res = 0;
    // 用于过程中记录最大深度的动态计数器
    let count = 0;
    const depth = root => {
        if (root == null) {
            // 此时说明已经达到最大深度，进行深度对比
            res = Math.max(res,count);
            return
        }
        count++
        depth(root.left);
        depth(root.right);
        count--
    }
    depth(root);
    return res
};
```

#### 二、medium类
[46.全排列](https://leetcode-cn.com/problems/permutations/)
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    // 创建两个新的变量，一个用于存放最终结果，一个用于记录路径
    let res = [];
    let count = [];
    const dfs = (nums,count) => {
      // 创建结束条件
        if (count.length == nums.length) {
            // 记录完整路径
            res.push([...count])
            return
        }
        for (let i = 0;i<nums.length;i++) {
            // 做出路径选择
            if (count.includes(nums[i])) {
                continue
            }
            // 记录当前路径
            count.push(nums[i]);
            dfs(nums,count);
            // 结束选择
            count.pop();
        }
    }
    dfs(nums,count)
    return res;
};
```

#### 三、hard类
[51.N皇后](https://leetcode-cn.com/problems/n-queens/)
```javascript
/**
 * @param {number} n
 * @return {string[][]}
 */
// 题目意思为：皇后的同列、同行、左上、左下、右上、右下均不能出现皇后
// 类似数独的题目
var solveNQueens = function(n) {
    let res = [];
    // 初始化二维数组
    let board = new Array(n).fill('.').map(()=> new Array(n).fill("."))
    const dfs = (board,row) => {
        if (row == board.length) {
          // 达到条件时，进行深拷贝
          // 并把数组中的每一个
            let str = [...board];
            // str中的每一项，都是一个子数组，子数组中的每一项都为一个位置上的字符串，所以需要遍历和拼接
            for (let i = 0;i<n;i++) {
                str[i] = str[i].join("");
            }
            return res.push(str)
        }
        let COL = board[row].length;
        for (let col = 0 ;col < COL;col++) {
          // 需要跳过的选择
            if (!isCanPush(board, row , col)){
                continue
            }
            board[row][col] = "Q"
            dfs(board, row+1)
            board[row][col] = "."
        }
    }
    dfs(board,0)
    return res;
};
// 由于是一行一行放置皇后，所以只需要确认该行的前几行在特定位置上是否有皇后
// 即之前的每一行中的左上方、正上方、右上方都不能出现皇后
const isCanPush = (board,row,col) => {
    let COL = board.length;
    // 判断整上方
    for (let i = 0 ; i< row; i++) {
        if (board[i][col] == "Q"){
            return false
        }
    }
    // 判断右上方
    for (let i = row -1,j = col+1; i >=0 && j< COL ; i-- , j++) {
        if (board[i][j] == "Q"){
            return false
        }
    }
    // 判断左上方
    for (let i = row -1, j = col -1 ;i>=0 && j>=0; i--,j--) {
        if(board[i][j] == "Q") {
            return false
        }
    }
    return true
}
```