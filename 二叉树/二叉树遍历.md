### 二叉树遍历

#### 一、easy类
[543.二叉树直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)
```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
// 获取最大路径，在遍历的后序进行深度的计算
var diameterOfBinaryTree = function(root) {
    let res = 0
    const dep = root => {
        if(root == null) {
            return 0
        }
        // 记录子节点的深度
        let left = dep(root.left)
        let right = dep(root.right)
        let max = left + right
        // 实时更新最大深度
        res = Math.max(res,max)
        // 每次递归都会返回自身深度1和左右节点中的最大深度
        return 1+ Math.max(left,right)
    }
    dep(root)
    return res
};
```
#### 二、medium类

#### 三、hard类
[124.二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
// 与543类似，同样是需要在后序位置进行值的相加
// 与543不同，至少要包含一个节点，并算出各个节点值的总和
// 所以需要在每一层递归返回值中，带上当前节点的val
var maxPathSum = function(root) {
    let res = -Infinity;
    const countMax = root => {
        if(root == null){
            return 0
        }
        // 遍历时，返回的是当前路径下的最大值
        let left = Math.max(0,countMax(root.left))
        let right = Math.max(0,countMax(root.right))
        // 值汇总
        let rootMax = root.val + left + right
        // 更新最大值
        res = Math.max(res,rootMax)
        // 每次递归返回自身值、最大的左右节点值
        return Math.max(left,right) + root.val
    }
    countMax(root)
    return res
};
```
