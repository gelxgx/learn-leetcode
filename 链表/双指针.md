### 双指针

#### 一、easy类
[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```javascript
// 这是一道经典双指针算法题
// 声明两个指针，分别指向两条链表
// 将这两条链表进行循环，循环中对比指针指向的值，根据情况分别添加至目标链表中，并继续更新链表节点
// 如果循环完了，出现某个链表没有遍历完的情况
// 就将这个链表直接全部添加至目标链表后
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(list1, list2) {
    let list = new ListNode(-1)
    let p = list
    let p1 = list1
    let p2 = list2
    while(p1 !== null && p2 !==null) {
        if (p1.val > p2.val) {
            p.next = p2
            p2 = p2.next
        } else {
            p.next = p1
            p1 = p1.next
        }
        p = p.next
    } 
    if (p1 !== null) {
        p.next = p1
    }
    if (p2 !== null) {
        p.next = p2
    }
    return list.next
};
```

[876.链表的中间节点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)
```javascript
// 快慢指针
// 快指针一次向前走两步
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var middleNode = function(head) {
    let fast = head
    let slow = head
    while(fast !== null && fast.next !== null) {
        fast = fast.next.next
        slow = slow.next
    }
    return slow
};
```

[141.环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)
```javascript
// 使用快慢指针，快指针一次走两步
// 如果出现快慢指针指向的值相同时，就说明链表有环
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let slow = head
    let fast = head
    while(fast && fast.next) {
        slow = slow.next
        fast = fast.next.next
        if (slow == fast) {
            return true
        }
    }
    return false
};
```

[160.相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```javascript
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
// 让两个链表产生交集
// 遍历完其中一个链表时，继续遍历另一个链表
var getIntersectionNode = function(headA, headB) {
    let a = headA
    let b = headB
    while(a != b) {
        if (a == null) {
            a = headB
        } else {
            a = a.next
        }
        if (b == null) {
            b = headA
        } else {
            b = b.next
        }
    }
    return a
};
```
#### 二、medium类
[19.删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)
```javascript
// 删除、查找倒数第N个节点时，最好采用快慢指针
// 先new一个fast指针，循环到需要找到的第n个节点
// 接着new一个slow指针，指向链表头部
// 两个指针继续同步向前
// slow指针指向的元素，就是要操作的元素

// 但对于删除来说，需要找到删除的前一个元素
// 所以需要找到第n+1个节点
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(-1)
    dummy.next = head
    let item = findEnd(dummy,n+1)
    item.next = item.next.next
    return dummy.next
};

const findEnd = (head,n) => {
    let p1 = head
    for(let i = 0;i<n;i++) {
        p1 = p1.next
    }
    let p2 = head
    while(p1 !== null) {
        p2 = p2.next
        p1 = p1.next
    }
    return p2
}
```

[142.环形链表](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
```javascript
// 当快慢指针相遇时。fast指针走过的路一定是slow指针的两倍
// 此时将慢指针置会原点
// 两个指针再继续循环，再次相遇时，就为环起点
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    let slow  = head
    let fast = head
    while(fast !== null && fast.next !== null) {
        slow = slow.next
        fast = fast.next.next
        if (slow == fast) {
            break
        }
    }
    if (fast == null || fast.next == null) {
        return null
    }
    slow = head
    while(slow != fast) {
        fast = fast.next
        slow = slow.next
    }
    return slow
};
```

#### 三、hard类
[23.合并k个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```javascript
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
// 这道题可以通过遍历链表数组中的每一个链表
// 用一个数组存放每一个链表中的元素的值
// 进行数组排序
// 再把数组元素转化成为链表
var mergeKLists = function(lists) {
    let arr = []
    let item
    lists.forEach(list => {
        item = list
        while(item) {
           arr.push(item.val)
           item  = item.next
        }
    })
    arr.sort((a,b) => a-b)
    let res = new ListNode(-1)
    node = res
    arr.forEach(item => {
        node.next = new ListNode(item)
        node = node.next
    })
    return res.next
};
```

TODO：这道题可以使用二叉堆解题，暂时还不会二叉堆……