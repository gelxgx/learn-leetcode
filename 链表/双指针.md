### 双指针

#### 一、easy类
[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```javascript
// 这是一道经典双指针算法题
// 声明两个指针，分别指向两条链表
// 将这两条链表进行循环，循环中对比指针指向的值，根据情况分别添加至目标链表中，并继续更新链表节点
// 如果循环完了，出现某个链表没有遍历完的情况
// 就将这个链表直接全部添加至目标链表后
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(list1, list2) {
    let list = new ListNode(-1)
    let p = list
    let p1 = list1
    let p2 = list2
    while(p1 !== null && p2 !==null) {
        if (p1.val > p2.val) {
            p.next = p2
            p2 = p2.next
        } else {
            p.next = p1
            p1 = p1.next
        }
        p = p.next
    } 
    if (p1 !== null) {
        p.next = p1
    }
    if (p2 !== null) {
        p.next = p2
    }
    return list.next
};
```
#### 二、medium类


#### 三、hard类
[23.合并k个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```javascript
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
// 这道题可以通过遍历链表数组中的每一个链表
// 用一个数组存放每一个链表中的元素的值
// 进行数组排序
// 再把数组元素转化成为链表
var mergeKLists = function(lists) {
    let arr = []
    let item
    lists.forEach(list => {
        item = list
        while(item) {
           arr.push(item.val)
           item  = item.next
        }
    })
    arr.sort((a,b) => a-b)
    let res = new ListNode(-1)
    node = res
    arr.forEach(item => {
        node.next = new ListNode(item)
        node = node.next
    })
    return res.next
};
```

TODO：这道题可以使用二叉堆解题，暂时还不会二叉堆……