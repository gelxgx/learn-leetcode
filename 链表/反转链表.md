### 反转链表

#### 一、easy类

[206.反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```javascript
// 使用递归的方式解决问题
// 每一次都取链表中该节点的下一个节点进行递归
// 并将当前节点的next指针指向的下一个节点的next指针，指向该节点

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if (head == null || head.next == null) {
        return head
    }
    let list = reverseList(head.next)
    head.next.next = head
    head.next = null
    return list
};
```
#### 二、medium类
[92.反转链表](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
```javascript
// 反转left到right的链表，转化为反转从头到right的链表
// 使用递归的方式进行链表反转的处理
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
var reverseBetween = function(head, left, right) {
    // left节点递归完毕
    // 开始递归right边界
    if(left == 1) {
        return resN(head,right)
    }
    head.next = reverseBetween(head.next,left-1,right-1)
    return head
};

let last = null
const resN = (head,n) => {
    // right边界递归完毕，记录right+1节点，开始翻转
    if(n == 1) {
        last = head.next
        return head
    }
    let list = resN(head.next,n-1)
    head.next.next = head
    head.next = last
    return list
}
```

#### 三、hard类
[25.k个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
```javascript
// 用for循环将链表“切割”成k个单位的子链表
// 再对子链表进行翻转
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    if(head == null) {
        return null
    }
    let a = b = head;
    for (let i = 0;i<k;i++) {
        if (b == null) {
            return head
        }
        b = b.next
    }
    let newHead = reserve(a,b)
    a.next = reverseKGroup(b,k)
    return newHead
};

const reserve = (a,b) => {
    let pre = null
    let next = curr = a
    while(curr !== b) {
        next = curr.next
        curr.next = pre
        pre = curr
        curr = next
    }
    return pre
}
```